/**
 * @file This module defines the `RaoidcClient` and `RaoidcClientBuilder` classes, which provide
 * a comprehensive client implementation for interacting with an RAOIDC auth provider.
 *
 * The client handles core OIDC flows and operations, including:
 *
 *   - Generating authorization requests for initiating user sign-in (PKCE flow).
 *   - Generating sign-out request URLs.
 *   - Handling the OIDC callback by exchanging an authorization code for tokens.
 *   - Generating client assertions (JWTs signed with the client's private key) for
 *     authenticating the client to the token endpoint.
 *   - Fetching access tokens, ID tokens, and userinfo tokens.
 *   - Decrypting and validating ID tokens and userinfo tokens.
 *   - Utility functions for generating cryptographic nonces, states, code verifiers,
 *     and JWK IDs.
 *
 * It utilizes the `jose` library for JWT and JWE operations, Node.js `crypto`
 * for hashing and random byte generation, and `undici` for HTTP requests.
 * Type validation for server responses is expected to be handled by schemas
 * imported from `~/.server/auth/response-validators`.
 */
import type { JWK } from 'jose';
import { compactDecrypt, decodeProtectedHeader, importJWK, jwtVerify, SignJWT } from 'jose';
import { createHash, randomBytes, webcrypto } from 'node:crypto';
import type { Dispatcher } from 'undici';
import { ProxyAgent, fetch as undiciFetch } from 'undici';
import * as v from 'valibot';

import type { RaoidcAccessToken, RaoidcIdTokenClaims, RaoidcUserinfoTokenClaims } from '~/.server/auth/response-validators';
import { RaoidcServerMetadataSchema, RsaJsonWebKeySetSchema } from '~/.server/auth/response-validators';
import { serverEnvironment } from '~/.server/environment';
import { LogFactory } from '~/.server/logging';
import { singleton } from '~/.server/utils/instance-registry';
import { AppError } from '~/errors/app-error';
import { ErrorCodes } from '~/errors/error-codes';

const log = LogFactory.getLogger(import.meta.url);

/**
 * A fetch function compatible with the Fetch API,
 * optionally customized with an `undici` Dispatcher.
 *
 * This type represents the signature of `undici.fetch`.
 *
 * @see https://undici.nodejs.org/#/docs/api/undici/fetch
 */
export type FetchFn = typeof undiciFetch;

/**
 * A parsed JSON Web Key Set (JWKS) from the RAOIDC server.
 *
 * This includes the RSA public keys used by the server to
 * sign or encrypt tokens, validated via the {@link RsaJsonWebKeySetSchema}.
 *
 * @see https://datatracker.ietf.org/doc/html/rfc7517 RFC 7517 - JSON Web Key (JWK)
 */
export type ServerJwks = v.InferOutput<typeof RsaJsonWebKeySetSchema>;

/**
 * An RAOIDC authentication server's metadata.
 * Returned by the OIDC server's discovery endpoint.
 *
 * @see https://datatracker.ietf.org/doc/html/rfc8414#section-2 RFC 8414 - OAuth 2.0 Authorization Server Metadata
 * @see https://openid.net/specs/openid-connect-discovery-1_0.html#RFC6749RFC6750RFC8414 OpenID Connect Discovery 1.0
 */
export type ServerMetadata = v.InferOutput<typeof RaoidcServerMetadataSchema>;

/**
 * Details of a sign-in request generated by the client.
 * These parameters are used to construct the authorization URL and validate
 * the subsequent callback.
 */
export type SigninRequest = {
  /**
   * The fully constructed URL to which the user agent should be redirected
   * to initiate the OIDC sign-in process.
   */
  readonly authUrl: URL;

  /**
   * The PKCE code verifier. This value must be stored securely by the client
   * and sent in the token request to prove possession of the client that
   * initiated the authorization request.
   * @see https://datatracker.ietf.org/doc/html/rfc7636#section-4.1
   */
  readonly codeVerifier: string;

  /**
   * A cryptographically random value used to associate a client session with an ID Token
   * and to mitigate replay attacks. This value is passed in the authorization request
   * and must be validated against the `nonce` claim in the ID Token.
   * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
   */
  readonly nonce: string;

  /**
   * An opaque value used by the client to maintain state between the request and
   * callback. It's also used to prevent cross-site request forgery.
   * @see https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1
   */
  readonly state: string;
};

/**
 * Represents the set of tokens obtained from the OIDC provider after a successful
 * authorization code exchange.
 */
export type TokenSet = {
  /**
   * The access token issued by the OIDC provider, used to access private resources.
   * Its structure is defined by {@link RaoidcAccessToken}.
   */
  readonly accessToken: RaoidcAccessToken;

  /**
   * The ID token (as claims) issued by the OIDC provider, containing authenticated
   * information about the user. Its structure is defined by {@link RaoidcIdTokenClaims}.
   */
  readonly idToken: RaoidcIdTokenClaims;

  /**
   * The user information token (as claims), typically obtained from the userinfo endpoint.
   * Its structure is defined by {@link RaoidcUserinfoTokenClaims}.
   */
  readonly userinfoToken: RaoidcUserinfoTokenClaims;
};

/**
 * Creates a new singleton RaoidcClient instance.
 */
export async function getRaoidcClient(): Promise<RaoidcClient> {
  return await singleton('raoidcClient', async () => {
    const raoidcClientBuilder = new RaoidcClientBuilder(
      new URL(serverEnvironment.AUTH_RAOIDC_BASE_URL),
      serverEnvironment.AUTH_RAOIDC_CLIENT_ID,
      serverEnvironment.AUTH_CLIENT_PRIVATE_KEY.value(),
      serverEnvironment.AUTH_CLIENT_PUBLIC_KEY,
    );

    if (serverEnvironment.AUTH_RAOIDC_PROXY_URL) {
      raoidcClientBuilder.withDispatcher(new ProxyAgent(serverEnvironment.AUTH_RAOIDC_PROXY_URL));
    }

    return await raoidcClientBuilder.build();
  });
}

/**
 * The `RaoidcClient` class provides methods to interact with an RAOIDC auth provider,
 * handling authorization flows, token exchange, and token validation.
 * It is designed to be instantiated by {@link RaoidcClientBuilder}.
 */
class RaoidcClient {
  /**
   * The base URL of the OIDC provider.
   */
  private readonly baseUrl: URL;

  /**
   * The client ID registered with the OIDC provider.
   */
  private readonly clientId: string;

  /**
   * The fetch function used for HTTP requests.
   */
  private readonly fetchFn: FetchFn;

  /**
   * The client's public RSA `CryptoKey` for encryption.
   */
  private readonly publicEncryptionCryptoKey: webcrypto.CryptoKey;

  /**
   * The client's public RSA `JsonWebKey` for encryption.
   */
  private readonly publicEncryptionJsonWebKey: webcrypto.JsonWebKey;

  /**
   * The client's private RSA key as a `CryptoKey` for JWE decryption (RSA-OAEP).
   */
  private readonly privateDecryptionCryptoKey: webcrypto.CryptoKey;

  /**
   * The client's private RSA key as a JWK for JWE decryption.
   */
  private readonly privateDecryptionJsonWebKey: webcrypto.JsonWebKey;

  /**
   * The client's public RSA `CryptoKey` for verification.
   */
  private readonly publicVerificationCryptoKey: webcrypto.CryptoKey;

  /**
   * The client's public RSA `JsonWebKey` for verification.
   */
  private readonly publicVerificationJsonWebKey: webcrypto.JsonWebKey;

  /**
   * The client's private RSA key as a `CryptoKey` for JWS signing (RSA-PSS).
   */
  private readonly privateSigningCryptoKey: webcrypto.CryptoKey;

  /**
   * The client's private RSA key as a JWK for JWS signing.
   */
  private readonly privateSigningJsonWebKey: webcrypto.JsonWebKey;

  /**
   * The OIDC provider's JSON Web Key Set (JWKS) used for verifying token signatures.
   */
  private readonly serverJwks: ServerJwks;

  /**
   * The OIDC provider's metadata discovery document.
   */
  private readonly serverMetadata: ServerMetadata;

  /**
   * Constructs an instance of `RaoidcClient`.
   * This constructor is typically called by `RaoidcClientBuilder`.
   *
   * @param baseUrl - The base URL of the OIDC provider.
   * @param clientId - The client ID for this application.
   * @param publicEncryptionCryptoKey - The client's public RSA `CryptoKey` for encryption.
   * @param publicEncryptionJsonWebKey - The client's public RSA `JsonWebKey` for encryption.
   * @param privateDecryptionCryptoKey - The client's private RSA `CryptoKey` for decryption.
   * @param privateDecryptionJsonWebKey - The client's private RSA `JsonWebKey` for decryption.
   * @param publicVerificationCryptoKey - The client's public RSA `CryptoKey` for verification.
   * @param publicVerificationJsonWebKey - The client's public RSA `JsonWebKey` for verification.
   * @param privateSigningCryptoKey - The client's private RSA `CryptoKey` for signing.
   * @param privateSigningJsonWebKey - The client's private RSA `JsonWebKey` for signing.
   * @param serverJwks - The OIDC provider's public JWKS.
   * @param serverMetadata - The OIDC provider's metadata.
   * @param opts - Optional parameters.
   * @param opts.fetchFn - An optional custom fetch function. Defaults to `undiciFetch`.
   */
  public constructor(
    baseUrl: URL,
    clientId: string,
    publicEncryptionCryptoKey: webcrypto.CryptoKey,
    publicEncryptionJsonWebKey: webcrypto.JsonWebKey,
    privateDecryptionCryptoKey: webcrypto.CryptoKey,
    privateDecryptionJsonWebKey: webcrypto.JsonWebKey,
    publicVerificationCryptoKey: webcrypto.CryptoKey,
    publicVerificationJsonWebKey: webcrypto.JsonWebKey,
    privateSigningCryptoKey: webcrypto.CryptoKey,
    privateSigningJsonWebKey: webcrypto.JsonWebKey,
    serverJwks: ServerJwks,
    serverMetadata: ServerMetadata,
    opts?: { fetchFn?: FetchFn },
  ) {
    this.baseUrl = baseUrl;
    this.clientId = clientId;
    this.publicEncryptionCryptoKey = publicEncryptionCryptoKey;
    this.publicEncryptionJsonWebKey = publicEncryptionJsonWebKey;
    this.privateDecryptionCryptoKey = privateDecryptionCryptoKey;
    this.privateDecryptionJsonWebKey = privateDecryptionJsonWebKey;
    this.publicVerificationCryptoKey = publicVerificationCryptoKey;
    this.publicVerificationJsonWebKey = publicVerificationJsonWebKey;
    this.privateSigningCryptoKey = privateSigningCryptoKey;
    this.privateSigningJsonWebKey = privateSigningJsonWebKey;
    this.serverJwks = serverJwks;
    this.serverMetadata = serverMetadata;

    this.fetchFn = opts?.fetchFn ?? undiciFetch;
  }

  /**
   * Generates a unique Key ID (kid) for a JSON Web Key (JWK) by creating an
   * MD5 hash of its modulus (`n`) property.
   *
   * @param jwk - The {@link webcrypto.JsonWebKey} (must be an RSA key with an 'n' property).
   * @returns A hexadecimal string representing the MD5 hash of the JWK's modulus.
   *          Returns an MD5 hash of an empty string if `jwk.n` is not present.
   */
  public generateJwkId(jwk: webcrypto.JsonWebKey): string {
    return createHash('md5') //
      .update(jwk.n ?? '')
      .digest('hex');
  }

  /**
   * Generates the necessary parameters for initiating an OIDC sign-in flow.
   * This includes the authorization URL, PKCE code verifier, nonce, and state.
   *
   * @param redirectUrl - The URL to which the OIDC provider should redirect the user
   *                      agent after authentication. This must match one of the
   *                      registered redirect URIs for the client.
   * @param opts - Optional parameters.
   * @param opts.scope - Optional. The OIDC scopes to request. Defaults to "openid profile".
   * @returns A {@link SigninRequest} object containing the `authUrl`, `codeVerifier`, `nonce`, and `state`.
   */
  public generateSigninRequest(redirectUrl: URL, opts?: { scope?: string }): SigninRequest {
    const { scope = 'openid profile' } = opts ?? {};

    const authorizationEndpointUrl = new URL(this.serverMetadata.authorization_endpoint, this.baseUrl);
    const { codeChallenge, codeVerifier } = this.generateCodeChallengeAndVerifier();
    const nonce = this.generateRandomNonce();
    const state = this.generateRandomState();

    const authUrl = this.generateAuthUrl(
      authorizationEndpointUrl,
      this.clientId,
      codeChallenge,
      nonce,
      redirectUrl,
      scope,
      state,
    );

    return { authUrl, codeVerifier, nonce, state };
  }

  /**
   * Generates the URL for initiating a sign-out request with RAOIDC.
   *
   * This method constructs the sign-out URL by expanding placeholders within a
   * predefined template URL string (obtained from `serverEnvironment.AUTH_LOGOUT_REDIRECT_URL`).
   *
   * The following placeholders are expected in the template and will be populated:
   *
   *   - `{clientId}`: Replaced with the instance's `this.clientId`.
   *   - `{sharedSessionId}`: Replaced with the provided `sessionId` parameter.
   *   - `{uiLocales}`: Replaced with the provided `locale` parameter.
   *
   * The resulting URL is intended to direct the user-agent to the RAOIDC sign-out endpoint.
   *
   * @param sessionId - The session identifier (e.g., an OIDC `sid` or a shared session ID)
   *                    that will be used to replace a corresponding placeholder
   *                    (like `{sharedSessionId}`) in the sign-out URL template.
   * @param language - The language or locale that will be used to replace a corresponding
   *                   placeholder (like `{uiLocales}`) in the sign-out URL template.
   * @returns A {@link URL} object representing the fully constructed sign-out URL.
   */
  public generateSignoutRequest(sessionId: string, language: string): URL {
    return new URL(
      this.expandTemplate(serverEnvironment.AUTH_RAOIDC_LOGOUT_URL, {
        clientId: this.clientId,
        sharedSessionId: sessionId,
        uiLocales: language,
      }),
    );
  }

  public getPublicEncryptionJsonWebKey(): webcrypto.JsonWebKey {
    return this.publicEncryptionJsonWebKey;
  }

  public getPublicVerificationJsonWebKey(): webcrypto.JsonWebKey {
    return this.publicVerificationJsonWebKey;
  }

  /**
   * Handles the OIDC callback request from the authorization server.
   * It exchanges the authorization code for tokens, validates them, and fetches user information.
   *
   * @param request - The incoming callback {@link Request} object from the user agent.
   * @param codeVerifier - The PKCE code verifier generated during the initial sign-in request.
   * @param expectedNonce - The nonce value sent in the original authorization request.
   * @param expectedState - The state value sent in the original authorization request.
   * @param callbackUrl - The client's registered callback URL (redirect_uri) that received this request.
   * @returns A promise that resolves to a {@link TokenSet} containing the access, ID, and userinfo tokens.
   * @throws {AppError} If the callback contains an error, is missing the authorization code,
   *                    if state validation fails, or if any step of token exchange or validation fails.
   */
  public async handleCallbackRequest(
    request: Request,
    codeVerifier: string,
    expectedNonce: string,
    expectedState: string,
    callbackUrl: URL,
    opts?: { birthdate?: string; locale?: string; sin?: string },
  ): Promise<TokenSet> {
    log.debug('Handling RAOIDC callback request...');

    const searchParams = new URL(request.url).searchParams;
    const error = searchParams.get('error');
    const authCode = searchParams.get('code');
    const state = searchParams.get('state');

    if (error) {
      throw new AppError(`Unexpected RAOIDC callback error: [${error}]`, ErrorCodes.AUTH_CALLBACK_ERROR);
    }

    if (!authCode) {
      throw new AppError('RAOIDC callback error: missing authorization code in response', ErrorCodes.AUTH_CALLBACK_ERROR);
    }

    if (state !== expectedState) {
      throw new AppError(
        `RAOIDC callback error: incoming state [${state}] does not match expected state [${expectedState}]`,
        ErrorCodes.AUTH_CALLBACK_ERROR,
      );
    }

    const { accessToken, idToken } = await this.fetchAccessAndIdTokens(authCode, codeVerifier, callbackUrl.toString());

    if (idToken.nonce !== expectedNonce) {
      throw new AppError(
        `RAOIDC callback error: id token nonce [${idToken.nonce}] does not match expected nonce [${expectedNonce}]; potential replay attack suspected`,
        ErrorCodes.AUTH_CALLBACK_ERROR,
      );
    }

    const { userinfoToken } = await this.fetchUserinfoToken(accessToken, opts);

    const tokenSet = {
      accessToken,
      idToken,
      userinfoToken,
    } as const;

    log.debug('Returning tokenset for sin [%s]: %o', userinfoToken.sin, tokenSet);

    return tokenSet;
  }

  /**
   * Validates a given session ID with the RAOIDC provider's session validation endpoint.
   *
   * This method constructs a request to the `/validatesession` endpoint at the
   * configured `serverEnvironment.AUTH_RAOIDC_BASE_URL`. It includes the
   * `client_id` (from `this.clientId`) and the provided `sessionId` as query parameters.
   *
   * It then makes a GET request to this URL using the instance's `fetchFn`.
   * If the response is not successful (i.e., `response.ok` is false), it throws an Error
   * containing the status code and the response body (if readable).
   *
   * For a successful response, it expects the RAOIDC provider to return a plain text
   * body containing either the string `'true'` or `'false'` to indicate the validity
   * of the session.
   *
   * @param sessionId The session identifier to be validated with the RAOIDC provider.
   * @returns A Promise that resolves to `true` if the session is valid (provider returns 'true'),
   *          and `false` otherwise (provider returns 'false').
   * @throws {AppError} if the network request fails or if the provider returns a non-ok HTTP status.
   */
  public async handleValidationRequest(sessionId: string): Promise<boolean> {
    log.debug('Handling RAOIDC session validation request...');

    const validationUrl = new URL('validatesession', serverEnvironment.AUTH_RAOIDC_BASE_URL);
    validationUrl.searchParams.set('client_id', this.clientId);
    validationUrl.searchParams.set('shared_session_id', sessionId);

    const validationResponse = await this.fetchFn(validationUrl);

    if (!validationResponse.ok) {
      const errorBody = await validationResponse.text().catch(() => 'N/A');
      throw new AppError(
        `Unexpected RAOIDC session validation error; status: [${validationResponse.status}]; body: [${errorBody}]`,
        ErrorCodes.AUTH_SESSION_VALIDATION_ERROR,
      );
    }

    // RAOIDC will return simply 'true' or 'false'
    // to indicate if the session is valid
    const isSessionValid = (await validationResponse.text()) === 'true';

    log.debug('Returning isSessionValid=[%s] for sessionId [%s]', isSessionValid, sessionId);

    return isSessionValid;
  }

  /**
   * Generates a client assertion JWT.
   * This JWT is used by the client to authenticate itself to the OIDC provider's token endpoint
   * when using the `private_key_jwt` client authentication method.
   * The assertion is signed with the client's private RSA key (using PS256).
   *
   * @returns A promise that resolves to the signed client assertion JWT string.
   * @see https://datatracker.ietf.org/doc/html/rfc7523#section-2.2 JWT Profile for OAuth 2.0 Client Authentication
   */
  private async generateClientAssertion(): Promise<string> {
    return await new SignJWT({})
      .setProtectedHeader({ alg: 'PS256', kid: this.generateJwkId(this.publicEncryptionJsonWebKey) })
      .setAudience(this.serverMetadata.issuer)
      .setExpirationTime('1m')
      .setIssuedAt()
      .setIssuer(this.clientId)
      .setJti(this.generateRandomString(32))
      .setNotBefore('30s ago')
      .setSubject(this.clientId)
      .sign(this.privateSigningCryptoKey);
  }

  /**
   * Fetches the access token and ID token from the OIDC provider's token endpoint
   * using the authorization code.
   *
   * @param authCode - The authorization code received from the authorization server.
   * @param codeVerifier - The PKCE code verifier.
   * @param redirectUri - The redirect URI that was used in the authorization request.
   * @returns A promise that resolves to an object containing the access token (string)
   *          and the decoded ID token claims ({@link RaoidcIdTokenClaims}).
   * @throws {AppError} If the token endpoint is not defined in server metadata,
   *                    if the token request fails, or if ID token decryption/validation fails.
   * @todo Implement more comprehensive ID token validation (e.g., `aud`, `iss`, `exp`, `iat`).
   */
  private async fetchAccessAndIdTokens(
    authCode: string,
    codeVerifier: string,
    redirectUri: string,
  ): Promise<{ accessToken: RaoidcAccessToken; idToken: RaoidcIdTokenClaims }> {
    if (!this.serverMetadata.token_endpoint) {
      throw new AppError('Token endpoint is not defined in OIDC server metadata.', ErrorCodes.AUTH_TOKEN_ENDPOINT_NOT_DEFINED);
    }

    const tokenResponse = await this.fetchFn(this.serverMetadata.token_endpoint, {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        client_id: this.clientId,
        client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer',
        client_assertion: await this.generateClientAssertion(),
        code: authCode,
        code_verifier: codeVerifier,
        grant_type: 'authorization_code',
        redirect_uri: redirectUri,
      }).toString(),
    });

    if (!tokenResponse.ok) {
      const errorBody = await tokenResponse.text().catch(() => 'N/A');
      throw new AppError(
        `Error fetching tokens: status [${tokenResponse.status}]; body: [${errorBody}]`,
        ErrorCodes.AUTH_TOKEN_FETCH_ERROR,
      );
    }

    const json = (await tokenResponse.json()) as { access_token: string; id_token: string; [key: string]: unknown };
    const { access_token, id_token } = json;

    if (typeof access_token !== 'string' || typeof id_token !== 'string') {
      throw new AppError('Token response did not include valid access_token or id_token.', ErrorCodes.AUTH_TOKEN_FETCH_ERROR);
    }

    const { plaintext: decryptedIdTokenBytes } = await compactDecrypt(id_token, this.privateDecryptionCryptoKey);
    const decryptedIdTokenJwt = Buffer.from(decryptedIdTokenBytes).toString('utf-8');

    const { alg, kid } = decodeProtectedHeader(decryptedIdTokenJwt);
    const verificationKey = this.serverJwks.keys.find((jwk) => jwk.kid === kid);

    if (!verificationKey) {
      throw new AppError(
        `No matching JWK found in server JWKS for kid: ${kid} to verify ID token.`,
        ErrorCodes.AUTH_TOKEN_FETCH_ERROR,
      );
    }

    const jwk = await importJWK(verificationKey as JWK, alg);
    const verifiedIdToken = await jwtVerify<RaoidcIdTokenClaims>(decryptedIdTokenJwt, jwk);

    return {
      accessToken: access_token,
      idToken: verifiedIdToken.payload,
    };
  }

  /**
   * Fetches the user information from the OIDC provider's userinfo endpoint
   * using the provided access token. The userinfo response is expected to be a JWE,
   * which is then decrypted and its inner JWT verified.
   *
   * @param accessToken - The access token obtained from the token endpoint.
   * @returns A promise that resolves to an object containing the decoded userinfo token claims
   *          ({@link RaoidcUserinfoTokenClaims}).
   * @throws {AppError} If the userinfo endpoint is not defined in server metadata,
   *                    if the request to the userinfo endpoint fails, or if the
   *                    userinfo token decryption or validation fails.
   */
  private async fetchUserinfoToken(
    accessToken: string,
    opts?: { birthdate?: string; locale?: string; sin?: string },
  ): Promise<{ userinfoToken: RaoidcUserinfoTokenClaims }> {
    if (!this.serverMetadata.userinfo_endpoint) {
      throw new AppError(
        'Userinfo endpoint is not defined in OIDC server metadata.',
        ErrorCodes.AUTH_USERINFO_ENDPOINT_NOT_DEFINED,
      );
    }

    const userinfoUrl = new URL(this.serverMetadata.userinfo_endpoint);

    if (serverEnvironment.AUTH_ENABLE_STUB_LOGIN) {
      if (opts?.birthdate) userinfoUrl.searchParams.set('birthdate', opts.birthdate);
      if (opts?.locale) userinfoUrl.searchParams.set('locale', opts.locale);
      if (opts?.sin) userinfoUrl.searchParams.set('sin', opts.sin);
    }

    const userinfoResponse = await this.fetchFn(userinfoUrl, {
      headers: {
        Accept: 'application/json, application/jwt',
        Authorization: `Bearer ${accessToken}`,
      },
    });

    if (!userinfoResponse.ok) {
      const errorBody = await userinfoResponse.text().catch(() => 'N/A');
      throw new AppError(
        `Error fetching userinfo: status: [${userinfoResponse.status}]; body: [${errorBody}]`,
        ErrorCodes.AUTH_USERINFO_FETCH_ERROR,
      );
    }

    const json = (await userinfoResponse.json()) as { userinfo_token: string; [key: string]: unknown };
    const { userinfo_token } = json;

    const { plaintext: decryptedUserinfoTokenBytes } = await compactDecrypt(userinfo_token, this.privateDecryptionCryptoKey);
    const decryptedUserinfoJwt = Buffer.from(decryptedUserinfoTokenBytes).toString('utf-8');

    const { alg, kid } = decodeProtectedHeader(decryptedUserinfoJwt);
    const verificationKey = this.serverJwks.keys.find((jwk) => jwk.kid === kid);

    if (!verificationKey) {
      throw new AppError(
        `No matching JWK found in server JWKS for kid: ${kid} to verify userinfo token.`,
        ErrorCodes.AUTH_USERINFO_FETCH_ERROR,
      );
    }

    const jwk = await importJWK(verificationKey as JWK, alg);
    const verifiedUserinfoToken = await jwtVerify<RaoidcUserinfoTokenClaims>(decryptedUserinfoJwt, jwk);

    return { userinfoToken: verifiedUserinfoToken.payload };
  }

  /**
   * Expands a string template using handlebar-like notation `{placeholder}`.
   *
   * @example
   * expandTemplate('{greeting}, {subject}!', { greeting: 'Hello', subject: 'world' })
   * // → 'Hello, world!'
   *
   * @param template - The string template with placeholders.
   * @param variables - An object where keys are placeholder names (without braces)
   *                    and values are their replacements.
   * @returns The template string with all placeholders replaced.
   */
  private expandTemplate(template: string, variables: Record<string, string>): string {
    return Object.entries(variables).reduce((t, [key, value]) => t.replaceAll(`{${key}}`, value), template);
  }

  /**
   * Generates the full authorization URL for an OIDC request.
   *
   * @param authorizationUrl - The base authorization endpoint URL from server metadata.
   * @param clientId - The client's ID.
   * @param codeChallenge - The PKCE code challenge (S256).
   * @param nonce - The nonce value.
   * @param redirectUrl - The client's redirect URI.
   * @param scope - The requested OIDC scopes.
   * @param state - The state value.
   * @returns A {@link URL} object representing the complete authorization request URL.
   * @see https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1 OAuth 2.0 Authorization Request
   * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest OIDC Authentication Request
   */
  private generateAuthUrl(
    authorizationUrl: URL,
    clientId: string,
    codeChallenge: string,
    nonce: string,
    redirectUrl: URL,
    scope: string,
    state: string,
  ): URL {
    const codeChallengeMethod = 'S256';
    const responseType = 'code';

    const authorizationRequest = new URL(authorizationUrl);
    authorizationRequest.searchParams.set('client_id', clientId);
    authorizationRequest.searchParams.set('code_challenge', codeChallenge);
    authorizationRequest.searchParams.set('code_challenge_method', codeChallengeMethod);
    authorizationRequest.searchParams.set('nonce', nonce);
    authorizationRequest.searchParams.set('redirect_uri', redirectUrl.toString());
    authorizationRequest.searchParams.set('response_type', responseType);
    authorizationRequest.searchParams.set('scope', scope);
    authorizationRequest.searchParams.set('state', state);

    return authorizationRequest;
  }

  /**
   * Generates a PKCE (Proof Key for Code Exchange) code verifier and its corresponding
   * SHA256 code challenge.
   *
   * @returns An object containing the `codeChallenge` (Base64URL-encoded SHA256 hash
   *          of the verifier) and the `codeVerifier` (a random Base64URL string).
   * @see https://datatracker.ietf.org/doc/html/rfc7636 PKCE by OAuth Public Clients
   * @see https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#pkce-code-challenge-method
   */
  private generateCodeChallengeAndVerifier(): { codeChallenge: string; codeVerifier: string } {
    const codeVerifier = this.generateRandomCodeVerifier();

    const codeChallenge = createHash('sha256') //
      .update(codeVerifier)
      .digest('base64url');

    return { codeChallenge, codeVerifier };
  }

  /**
   * Generates a cryptographically random string suitable for use as an OIDC PKCE code verifier.
   * The string is Base64URL encoded.
   *
   * @param len - The desired length of the random string before Base64URL encoding.
   *              The output string length will be approximately `len * 4 / 3`.
   *              RFC 7636 recommends a verifier length between 43 and 128 characters.
   *              A common raw byte length is 32 to 48 bytes. Default is 64 here for safety.
   * @returns A Base64URL-encoded random string.
   * @see https://datatracker.ietf.org/doc/html/rfc7636#section-4.1 PKCE Code Verifier
   */
  private generateRandomCodeVerifier(len = 64): string {
    return this.generateRandomString(len);
  }

  /**
   * Generates a cryptographically random string suitable for use as an OIDC nonce.
   * The string is Base64URL encoded.
   *
   * @param len - The desired length of the random string. Default is 32 characters.
   * @returns A Base64URL-encoded random string.
   * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest Nonce requirement
   */
  private generateRandomNonce(len = 32): string {
    return this.generateRandomString(len);
  }

  /**
   * Generates a cryptographically random string suitable for use as an OIDC state parameter.
   * The string is Base64URL encoded.
   *
   * @param len - The desired length of the random string. Default is 32 characters.
   * @returns A Base64URL-encoded random string.
   * @see https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1 State parameter
   */
  private generateRandomState(len = 32): string {
    return this.generateRandomString(len);
  }

  /**
   * Generates a cryptographically random string of a specified final length,
   * encoded in Base64URL format.
   *
   * @param len - The desired final length of the Base64URL string. The number of
   *              random bytes generated will be `ceil(len * 3 / 4)`.
   * @returns A Base64URL-encoded random string of the specified length.
   */
  private generateRandomString(len: number): string {
    return randomBytes(len).toString('base64url').slice(0, len);
  }
}

/**
 * Builder class for `RaoidcClient`.
 * It configures and instantiates a `RaoidcClient` by fetching server metadata,
 * processing cryptographic keys, and setting up HTTP client options.
 *
 * The builder handles:
 *
 *   - Initialization with essential OpenID Connect (OIDC) provider details such as
 *     base URL, client ID, and the client's private RSA key in PEM format.
 *   - Fetching OIDC server metadata (discovery document) and the JSON Web Key Set (JWKS)
 *     from the OIDC provider.
 *   - Parsing and importing the provided private PEM key into WebCrypto `CryptoKey`
 *     objects suitable for decryption (RSA-OAEP) and signing (RSA-PSS).
 *   - Allowing customization of the HTTP fetch function, particularly for integrating
 *     custom Undici dispatchers.
 *   - Assembling all necessary configuration and cryptographic keys to instantiate
 *     the `RaoidcClient`.
 *
 * It leverages Node.js's `webcrypto` for cryptographic operations, `undici` for
 * HTTP requests, and `valibot` for validating server responses.
 */
class RaoidcClientBuilder {
  /**
   * The base URL of the OIDC provider. Must include a trailing slash.
   */
  private readonly baseUrl: URL;

  /**
   * The client ID registered with the RAOIDC provider.
   */
  private readonly clientId: string;

  /**
   * The client's private RSA key in PKCS#8 format, used for decryption and signing.
   */
  private readonly privateKeyPem: string;

  /**
   * The client's public RSA key in PEM format, used for encryption and validation.
   */
  private readonly publicKeyPem: string;

  /**
   * The fetch function to be used for HTTP requests. Defaults to `undiciFetch`.
   */
  private fetchFn: FetchFn;

  /**
   * Constructs an instance of `RaoidcClientBuilder`.
   *
   * @param baseUrl - The base URL of the OIDC provider. It must end with a trailing slash.
   * @param clientId - The client ID for this application.
   * @param privateKeyPem - The client's private RSA key in PEM format.
   * @throws {AppError} If the `baseUrl` does not have a trailing slash.
   */
  public constructor(baseUrl: URL, clientId: string, privateKeyPem: string, publicKeyPem: string) {
    if (!baseUrl.pathname.endsWith('/')) {
      throw new AppError('baseUrl must have trailing slash');
    }

    this.baseUrl = baseUrl;
    this.clientId = clientId;
    this.privateKeyPem = privateKeyPem;
    this.publicKeyPem = publicKeyPem;
    this.fetchFn = undiciFetch;
  }

  /**
   * Overrides the default `fetch` function, typically to use a custom Undici `Dispatcher`.
   * This allows for fine-grained control over HTTP requests, such as connection pooling,
   * custom agents, proxying, or mocking for tests.
   *
   * @param dispatcher - An Undici `Dispatcher` instance to handle HTTP requests.
   * @returns The `RaoidcClientBuilder` instance for method chaining.
   */
  public withDispatcher(dispatcher: Dispatcher): this {
    this.fetchFn = (input, init) => undiciFetch(input, { ...init, dispatcher });
    return this;
  }

  /**
   * Builds and initializes a new {@link RaoidcClient} instance.
   *
   * This asynchronous method performs several key setup steps:
   *
   *   1. Generates `CryptoKey` objects from the provided `privateKeyPem` for both
   *      decryption (RSA-OAEP) and signing (RSA-PSS) operations.
   *   2. Exports these `CryptoKey` objects to their JSON Web Key (JWK) format.
   *   3. Fetches the OIDC provider's metadata.
   *   4. Fetches the OIDC provider's JSON Web Key Set (JWKS) using the `jwks_uri`
   *      from the fetched metadata.
   *   5. Constructs and returns a new `RaoidcClient` with all the gathered information
   *      and generated keys.
   *
   * @returns A promise that resolves to a fully configured `RaoidcClient` instance.
   */
  public async build(): Promise<RaoidcClient> {
    log.info('Building RaoidcClient...');

    log.debug('Generating public encryption key...');
    const publicEncryptionCryptoKey = await this.generateCryptoKey(this.publicKeyPem, 'encrypt');
    const publicEncryptionJsonWebKey = await webcrypto.subtle.exportKey('jwk', publicEncryptionCryptoKey);

    log.debug('Generating private decryption key...');
    const privateDecryptionCryptoKey = await this.generateCryptoKey(this.privateKeyPem, 'decrypt');
    const privateDecryptionJsonWebKey = await webcrypto.subtle.exportKey('jwk', privateDecryptionCryptoKey);

    log.debug('Generating public verification key...');
    const publicVerificationCryptoKey = await this.generateCryptoKey(this.publicKeyPem, 'verify');
    const publicVerificationJsonWebKey = await webcrypto.subtle.exportKey('jwk', publicVerificationCryptoKey);

    log.debug('Generating private signing key...');
    const privateSigningCryptoKey = await this.generateCryptoKey(this.privateKeyPem, 'sign');
    const privateSigningJsonWebKey = await webcrypto.subtle.exportKey('jwk', privateSigningCryptoKey);

    log.debug('Fetching server metadata and JWKS...');
    const serverMetadata = await this.fetchServerMetadata();
    const serverJwks = await this.fetchServerJwks(serverMetadata.jwks_uri);
    log.info('RaoidcClient build complete.');

    return new RaoidcClient(
      this.baseUrl,
      this.clientId,
      publicEncryptionCryptoKey,
      publicEncryptionJsonWebKey,
      privateDecryptionCryptoKey,
      privateDecryptionJsonWebKey,
      publicVerificationCryptoKey,
      publicVerificationJsonWebKey,
      privateSigningCryptoKey,
      privateSigningJsonWebKey,
      serverJwks,
      serverMetadata,
      { fetchFn: this.fetchFn },
    );
  }

  /**
   * Extracts the Base64-encoded key data from a PEM-formatted string.
   * It removes the PEM header and footer and any whitespace characters from the Base64 content.
   *
   * @param pem - The PEM-formatted string (e.g., "-----BEGIN PRIVATE KEY-----...-----END PRIVATE KEY-----").
   * @param expectedHeader - The expected PEM header (e.g., "-----BEGIN PRIVATE KEY-----").
   * @param expectedFooter - The expected PEM footer (e.g., "-----END PRIVATE KEY-----").
   * @returns A {@link Buffer} containing the raw binary key data.
   * @throws {AppError} If the PEM string does not contain the expected header and footer.
   */
  private extractPemKeyData(pem: string, expectedHeader: string, expectedFooter: string): Buffer<ArrayBuffer> {
    const headerPos = pem.indexOf(expectedHeader);
    const footerPos = pem.indexOf(expectedFooter);

    if (headerPos === -1 || footerPos === -1 || footerPos < headerPos) {
      throw new AppError(`PEM string must contain standard headers "${expectedHeader}" and "${expectedFooter}".`);
    }

    const base64Content = pem.substring(headerPos + expectedHeader.length, footerPos);
    const cleanedBase64 = base64Content.replace(/[\s]/g, ''); // remove whitespace

    return Buffer.from(cleanedBase64, 'base64');
  }

  /**
   * Fetches the JSON Web Key Set (JWKS) from the OIDC provider's `jwks_uri`.
   * The JWKS contains the provider's public keys used to verify token signatures.
   *
   * @param jwksUrl - The absolute URL to the JWKS endpoint, typically obtained from server metadata.
   * @returns A promise that resolves to the parsed {@link ServerJwks}.
   * @throws {AppError} If the HTTP request fails or the response cannot be parsed or validated.
   */
  private async fetchServerJwks(jwksUrl: URL): Promise<ServerJwks> {
    log.debug(`Fetching JWKS from ${jwksUrl.toString()}`);

    const response = await this.fetchFn(new URL(jwksUrl, this.baseUrl));

    if (!response.ok) {
      const errorBody = await response.text().catch(() => 'N/A');
      throw new AppError(
        `Error fetching jwks: status: [${response.status}]; body: [${errorBody}]`,
        ErrorCodes.AUTH_JWKS_FETCH_ERROR,
      );
    }

    const json = await response.json();
    return v.parse(RsaJsonWebKeySetSchema, json);
  }

  /**
   * Fetches the OIDC provider's metadata from its well-known configuration endpoint
   * (`.well-known/openid-configuration`). This metadata includes crucial endpoints
   * like `jwks_uri`, `authorization_endpoint`, `token_endpoint`, etc.
   *
   * @returns A promise that resolves to the parsed {@link ServerMetadata}.
   * @throws {AppError} If the HTTP request fails or the response cannot be parsed or validated.
   */
  private async fetchServerMetadata(): Promise<ServerMetadata> {
    const metadataUrl = new URL('.well-known/openid-configuration', this.baseUrl);
    log.debug(`Fetching OIDC server metadata from ${metadataUrl.toString()}`);

    const response = await this.fetchFn(metadataUrl);

    if (!response.ok) {
      const errorBody = await response.text().catch(() => 'N/A');
      throw new AppError(
        `Error fetching server metadata: status: [${response.status}]; body: [${errorBody}]`,
        ErrorCodes.AUTH_METADATA_FETCH_ERROR,
      );
    }

    const json = await response.json();
    return v.parse(RaoidcServerMetadataSchema, json);
  }

  /**
   * Imports a PEM-encoded RSA key and converts it into a `webcrypto.CryptoKey` object.
   * This method supports importing keys for different cryptographic operations (encrypt, decrypt, sign, verify)
   * and handles the distinction between public (SPKI) and private (PKCS#8) key formats.
   *
   * @param pem - The PEM-encoded key string.
   * @param operation - The intended cryptographic operation for the key.
   *                    - 'encrypt': Imports an RSA public key (SPKI) for RSA-OAEP encryption.
   *                    - 'decrypt': Imports an RSA private key (PKCS#8) for RSA-OAEP decryption.
   *                    - 'sign': Imports an RSA private key (PKCS#8) for RSA-PSS signing.
   *                    - 'verify': Imports an RSA public key (SPKI) for RSA-PSS signature verification.
   * @returns A promise that resolves to a `webcrypto.CryptoKey`.
   * @throws If PEM parsing fails or the key import operation fails.
   */
  private async generateCryptoKey(
    pem: string,
    operation: 'encrypt' | 'decrypt' | 'sign' | 'verify',
  ): Promise<webcrypto.CryptoKey> {
    log.debug(`Generating CryptoKey for operation: ${operation}`);

    switch (operation) {
      /**
       * Creates a public RSA encryption CryptoKey (RSA-OAEP).
       */
      case 'encrypt': {
        const header = '-----BEGIN PUBLIC KEY-----';
        const footer = '-----END PUBLIC KEY-----';

        const format = 'spki' satisfies webcrypto.KeyFormat;
        const keyData = this.extractPemKeyData(pem, header, footer);
        const algorithm = { name: 'RSA-OAEP', hash: 'SHA-256' } satisfies webcrypto.RsaHashedImportParams;
        const extractable = true;
        const keyUsages = ['encrypt', 'wrapKey'] satisfies webcrypto.KeyUsage[];

        return await webcrypto.subtle.importKey(format, keyData, algorithm, extractable, keyUsages);
      }

      /**
       * Creates a private RSA decryption CryptoKey (RSA-OAEP).
       */
      case 'decrypt': {
        const header = '-----BEGIN PRIVATE KEY-----';
        const footer = '-----END PRIVATE KEY-----';

        const format = 'pkcs8' satisfies webcrypto.KeyFormat;
        const keyData = this.extractPemKeyData(pem, header, footer);
        const algorithm = { name: 'RSA-OAEP', hash: 'SHA-256' } satisfies webcrypto.RsaHashedImportParams;
        const extractable = true;
        const keyUsages = ['decrypt', 'unwrapKey'] satisfies webcrypto.KeyUsage[];

        return await webcrypto.subtle.importKey(format, keyData, algorithm, extractable, keyUsages);
      }

      /**
       * Creates a private RSA signing CryptoKey (RSA-PSS).
       */
      case 'sign': {
        const header = '-----BEGIN PRIVATE KEY-----';
        const footer = '-----END PRIVATE KEY-----';

        const format = 'pkcs8' satisfies webcrypto.KeyFormat;
        const keyData = this.extractPemKeyData(pem, header, footer);
        const algorithm = { name: 'RSA-PSS', hash: 'SHA-256' } satisfies webcrypto.RsaHashedImportParams;
        const extractable = true;
        const keyUsages = ['sign'] satisfies webcrypto.KeyUsage[];

        return await webcrypto.subtle.importKey(format, keyData, algorithm, extractable, keyUsages);
      }

      /**
       * Creates a public RSA signature verification CryptoKey (RSA-PSS).
       */
      case 'verify': {
        const header = '-----BEGIN PUBLIC KEY-----';
        const footer = '-----END PUBLIC KEY-----';

        const format = 'spki' satisfies webcrypto.KeyFormat;
        const keyData = this.extractPemKeyData(pem, header, footer);
        const algorithm = { name: 'RSA-PSS', hash: 'SHA-256' } satisfies webcrypto.RsaHashedImportParams;
        const extractable = true;
        const keyUsages = ['verify'] satisfies webcrypto.KeyUsage[];

        return await webcrypto.subtle.importKey(format, keyData, algorithm, extractable, keyUsages);
      }
    }
  }
}
